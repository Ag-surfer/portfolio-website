import { Skill } from './types';

export const skills: Skill[] = [
  {
    id: 'skill-1',
    slug: 'react-nextjs',
    name: 'React / Next.js',
    category: 'frontend',
    proficiency: 90,
    icon: 'react',
    logoPath: '/logos/skills/react.svg',
    modelPath: '/models/skills/react.glb',
    description:
      'Building fast, interactive UIs with React and production-grade apps with Next.js.',
    longDescription:
      'React has been the foundation of my frontend work for four years. I started with class components and have evolved through hooks, context, server components, and the App Router. I reach for Next.js on every new project because it handles the hard parts -- routing, SSR, image optimization, API routes -- so I can focus on the product. I care deeply about component architecture: small, composable pieces that are easy to test and reason about.',
    highlights: [
      'Built 10+ production apps with Next.js App Router and Server Components',
      'Created a 40-component design system with Framer Motion animations',
      'Reduced bundle size by 35% through code splitting and lazy loading',
      'Implemented real-time collaboration features using React concurrent mode',
    ],
    relatedProjectSlugs: [
      'collaborative-workspace',
      'analytics-dashboard',
      'motion-design-system',
    ],
    yearsOfExperience: 4,
    roadmap: [
      {
        level: 'beginner',
        label: 'Beginner',
        topics: [
          { title: 'JSX syntax & expressions', description: 'The templating language that lets you write HTML-like markup inside JavaScript. It is the foundation for describing what your UI should look like.' },
          { title: 'Props & component composition', description: 'Passing data between components and nesting them together to build complex UIs from simple, reusable pieces.' },
          { title: 'State with useState', description: 'Managing dynamic data that changes over time within a component. This is how you make interfaces interactive and responsive to user input.' },
          { title: 'Event handling', description: 'Responding to user actions like clicks, form submissions, and keyboard input. Essential for building any interactive interface.' },
          { title: 'Conditional rendering', description: 'Showing or hiding elements based on application state. This lets you build dynamic UIs that adapt to different scenarios.' },
          { title: 'Lists & keys', description: 'Rendering arrays of data efficiently by giving each element a stable identity. Keys help React track which items changed, were added, or removed.' },
          { title: 'Basic CSS-in-JS / Tailwind', description: 'Styling components using utility classes or JavaScript-based approaches. Tailwind provides a fast, consistent way to build designs without writing custom CSS.' },
        ],
      },
      {
        level: 'intermediate',
        label: 'Intermediate',
        topics: [
          { title: 'Custom hooks', description: 'Extracting and reusing stateful logic across multiple components. Custom hooks keep your components clean and your logic testable.' },
          { title: 'Context API & providers', description: 'Sharing state across deeply nested components without prop drilling. Useful for themes, authentication, and other app-wide concerns.' },
          { title: 'useEffect & data fetching', description: 'Synchronizing components with external systems and loading data from APIs. Understanding the effect lifecycle prevents common bugs like memory leaks.' },
          { title: 'React Router / Next.js routing', description: 'Navigating between pages and handling URL-based state. Next.js file-based routing simplifies this with conventions over configuration.' },
          { title: 'Form handling & validation', description: 'Managing form state, validating user input, and providing feedback. Good form UX directly impacts conversion rates and user satisfaction.' },
          { title: 'Error boundaries', description: 'Catching rendering errors gracefully so a bug in one component does not crash the entire application.' },
          { title: 'Code splitting with lazy/Suspense', description: 'Loading parts of your application on demand to reduce initial bundle size. This improves page load times significantly for larger apps.' },
        ],
      },
      {
        level: 'advanced',
        label: 'Advanced',
        topics: [
          { title: 'Server Components & SSR', description: 'Rendering components on the server to send less JavaScript to the browser. This dramatically improves initial load performance and SEO.' },
          { title: 'Streaming & progressive rendering', description: 'Sending HTML to the browser in chunks as it becomes ready. Users see content faster instead of waiting for the entire page to render.' },
          { title: 'Caching strategies (ISR, on-demand)', description: 'Balancing freshness and performance by choosing when to regenerate pages. Incremental Static Regeneration lets you serve static pages that stay up to date.' },
          { title: 'Optimistic UI updates', description: 'Updating the interface immediately before the server confirms a change. This makes apps feel instant even on slow connections.' },
          { title: 'Concurrent features & transitions', description: 'Keeping the UI responsive during expensive renders by marking updates as non-urgent. Transitions let React prioritize what the user sees first.' },
          { title: 'Bundle analysis & tree-shaking', description: 'Identifying and eliminating unused code from your production bundles. Smaller bundles mean faster load times and lower bandwidth costs.' },
          { title: 'Advanced state management patterns', description: 'Handling complex state with reducers, state machines, or external stores. Choosing the right pattern prevents spaghetti state as apps grow.' },
        ],
      },
      {
        level: 'expert',
        label: 'Expert',
        topics: [
          { title: 'Architecture for large-scale apps', description: 'Organizing code, defining boundaries, and establishing patterns that keep a growing codebase maintainable across multiple teams.' },
          { title: 'Performance profiling & optimization', description: 'Using React DevTools and browser profilers to find and fix rendering bottlenecks. Targeted optimization beats guessing every time.' },
          { title: 'Custom renderers & reconciliation', description: 'Building renderers that target non-DOM environments like canvas, PDF, or native platforms. Understanding reconciliation reveals how React actually works under the hood.' },
          { title: 'Comprehensive testing strategies', description: 'Combining unit, integration, and end-to-end tests to catch bugs without slowing down development. A good testing pyramid gives confidence to ship fast.' },
          { title: 'Design system architecture', description: 'Building a shared component library with tokens, variants, and documentation that scales across products and teams.' },
          { title: 'Monorepo component libraries', description: 'Managing shared UI packages across multiple apps using tools like Turborepo or Nx. Monorepos keep dependencies in sync and simplify cross-project changes.' },
          { title: 'Migration & upgrade strategies', description: 'Planning and executing major version upgrades or framework migrations without disrupting active development or users.' },
        ],
      },
    ],
  },
  {
    id: 'skill-2',
    slug: 'typescript',
    name: 'TypeScript',
    category: 'frontend',
    proficiency: 85,
    icon: 'typescript',
    logoPath: '/logos/skills/typescript.svg',
    modelPath: '/models/skills/typescript.glb',
    description:
      'Writing type-safe code that catches bugs at compile time, not in production.',
    longDescription:
      'I switched to TypeScript three years ago and never looked back. Strict mode is non-negotiable on my projects. I use discriminated unions for state machines, generics for reusable utilities, and Zod for runtime validation that stays in sync with my types. TypeScript makes refactoring fearless -- when I rename a prop or change an API response shape, the compiler tells me every place that needs updating.',
    highlights: [
      'Strict mode enabled on all projects with zero any-casts in production code',
      'Built type-safe API clients using generics and Zod schema inference',
      'Created custom utility types for complex form validation patterns',
    ],
    relatedProjectSlugs: [
      'collaborative-workspace',
      'analytics-dashboard',
      'event-booking-api',
      'motion-design-system',
    ],
    yearsOfExperience: 3,
    roadmap: [
      {
        level: 'beginner',
        label: 'Beginner',
        topics: [
          { title: 'Primitive types & type annotations', description: 'Declaring the shape of your data with string, number, boolean, and other basic types. Annotations catch type mismatches before your code runs.' },
          { title: 'Interfaces & type aliases', description: 'Defining reusable shapes for objects and data structures. Interfaces and type aliases are the building blocks of every TypeScript codebase.' },
          { title: 'Enums & literal types', description: 'Representing a fixed set of values like status codes or directions. Literal types narrow values to exact strings or numbers for safer code.' },
          { title: 'Arrays & tuples', description: 'Typing ordered collections of data with fixed or variable lengths. Tuples let you enforce exact element types at each position.' },
          { title: 'Function signatures', description: 'Specifying parameter types and return types for functions. Clear signatures serve as documentation and prevent incorrect usage.' },
          { title: 'Union & intersection types', description: 'Combining types to represent values that can be one of several shapes or must satisfy multiple constraints at once.' },
          { title: 'Type inference basics', description: 'Letting TypeScript automatically determine types from context so you write fewer annotations while keeping full type safety.' },
        ],
      },
      {
        level: 'intermediate',
        label: 'Intermediate',
        topics: [
          { title: 'Generics & constraints', description: 'Writing functions and types that work with multiple data shapes while preserving type information. Generics are essential for reusable, type-safe utilities.' },
          { title: 'Utility types (Partial, Pick, Omit)', description: 'Built-in type transformations that derive new types from existing ones. They reduce duplication and keep related types in sync automatically.' },
          { title: 'Type guards & narrowing', description: 'Refining a broad type to a more specific one within a code block. Narrowing lets you safely access properties that only exist on certain variants.' },
          { title: 'Discriminated unions', description: 'Modeling state machines and tagged variants with a shared literal field. This pattern makes impossible states unrepresentable in your type system.' },
          { title: 'Index signatures & Record', description: 'Typing objects with dynamic keys when the exact property names are not known ahead of time. Record provides a cleaner syntax for key-value mappings.' },
          { title: 'Module augmentation', description: 'Extending third-party types to add custom properties or fix incorrect definitions. This keeps your code type-safe even when libraries fall short.' },
          { title: 'Zod & runtime validation', description: 'Defining schemas that validate data at runtime and infer TypeScript types automatically. This bridges the gap between compile-time types and real-world input.' },
        ],
      },
      {
        level: 'advanced',
        label: 'Advanced',
        topics: [
          { title: 'Mapped types & template literals', description: 'Transforming every property in a type programmatically and constructing string types from patterns. These features power advanced type-level abstractions.' },
          { title: 'Conditional types & infer', description: 'Building types that branch based on conditions and extract nested type information. This enables sophisticated type transformations that adapt to their input.' },
          { title: 'Decorators & metadata', description: 'Adding annotations to classes and methods that can modify behavior at runtime. Common in frameworks like NestJS for dependency injection and routing.' },
          { title: 'Variance & covariance', description: 'Understanding how subtype relationships flow through generics and function parameters. Variance determines when one generic type can substitute for another.' },
          { title: 'Recursive types', description: 'Defining types that reference themselves to model tree structures, JSON, or deeply nested data. Recursive types let you describe data of arbitrary depth.' },
          { title: 'Branded / nominal types', description: 'Creating distinct types that are structurally identical but semantically different, like UserId vs OrderId. This prevents accidentally mixing up values that share the same shape.' },
          { title: 'Declaration files & .d.ts authoring', description: 'Writing type definitions for untyped JavaScript libraries so they integrate seamlessly with TypeScript projects.' },
        ],
      },
      {
        level: 'expert',
        label: 'Expert',
        topics: [
          { title: 'Compiler API & custom transforms', description: 'Programmatically analyzing and transforming TypeScript code using the compiler API. Useful for building code generators, linters, and custom tooling.' },
          { title: 'Declaration merging & augmentation', description: 'Combining multiple declarations of the same entity to extend interfaces and namespaces across files and modules.' },
          { title: 'Type-level programming', description: 'Using the type system as a programming language to compute types, enforce invariants, and build domain-specific type DSLs.' },
          { title: 'Performance tuning (type complexity)', description: 'Diagnosing and fixing slow type-checking caused by deeply nested or excessively complex types. Fast type-checks keep the developer experience smooth.' },
          { title: 'Custom ESLint rules with type info', description: 'Writing lint rules that leverage TypeScript type information to catch domain-specific bugs that generic rules miss.' },
          { title: 'Monorepo type strategies', description: 'Managing shared types, project references, and build configurations across multiple packages in a monorepo.' },
          { title: 'Migration of large JS codebases', description: 'Incrementally adding TypeScript to existing JavaScript projects without disrupting ongoing development. A phased approach minimizes risk and keeps teams productive.' },
        ],
      },
    ],
  },
  {
    id: 'skill-3',
    slug: 'nodejs-backend',
    name: 'Node.js / Backend',
    category: 'backend',
    proficiency: 85,
    icon: 'nodejs',
    logoPath: '/logos/skills/nodejs.svg',
    modelPath: '/models/skills/nodejs.glb',
    description:
      'Designing APIs and backend systems that are fast, reliable, and easy to maintain.',
    longDescription:
      'I have been building backend services with Node.js for four years, from simple REST APIs to event-driven architectures handling thousands of concurrent connections. I think carefully about data flow, error handling, and observability. My APIs come with OpenAPI documentation, structured logging, and comprehensive test suites. I have experience with Express, Fastify, and Next.js API routes, and I pick the right tool based on the problem.',
    highlights: [
      'Built a booking API handling 5,000+ concurrent requests with zero oversells',
      'Designed event-driven architectures using Redis pub/sub and message queues',
      'Implemented rate limiting, caching, and circuit breaker patterns',
      'Maintained 95%+ test coverage on all backend services',
    ],
    relatedProjectSlugs: [
      'collaborative-workspace',
      'event-booking-api',
      'ai-content-engine',
    ],
    yearsOfExperience: 4,
    roadmap: [
      {
        level: 'beginner',
        label: 'Beginner',
        topics: [
          { title: 'Core modules (fs, path, http)', description: 'The built-in modules that let Node.js read files, resolve paths, and serve HTTP without any external dependencies.' },
          { title: 'npm & package management', description: 'Installing, updating, and managing third-party libraries. Understanding package.json and lock files keeps your dependencies predictable.' },
          { title: 'HTTP request/response cycle', description: 'How a client request travels to your server and how the response gets sent back. This mental model is essential for debugging any web application.' },
          { title: 'Environment variables', description: 'Storing configuration like API keys and database URLs outside your code. This keeps secrets safe and lets the same code run in different environments.' },
          { title: 'Basic file I/O', description: 'Reading and writing files on the server using synchronous and asynchronous APIs. File operations are fundamental to logging, data processing, and configuration.' },
          { title: 'JSON APIs', description: 'Sending and receiving structured data between client and server using JSON. This is the most common format for web API communication.' },
          { title: 'Error handling basics', description: 'Catching and responding to errors gracefully so your server stays running and users get helpful feedback instead of cryptic failures.' },
        ],
      },
      {
        level: 'intermediate',
        label: 'Intermediate',
        topics: [
          { title: 'Express / Fastify middleware', description: 'Composable functions that process requests before they reach your route handlers. Middleware handles cross-cutting concerns like logging, auth, and CORS.' },
          { title: 'RESTful API design', description: 'Structuring endpoints around resources with consistent naming, proper HTTP methods, and meaningful status codes. Good API design makes integration straightforward.' },
          { title: 'Input validation & sanitization', description: 'Checking that incoming data matches expected formats and stripping harmful content. This is your first line of defense against bad data and injection attacks.' },
          { title: 'Authentication (JWT, sessions)', description: 'Verifying user identity using tokens or server-side sessions. Choosing the right auth strategy affects security, scalability, and user experience.' },
          { title: 'Database integration (Prisma)', description: 'Connecting your API to a database with type-safe queries using Prisma ORM. This eliminates raw SQL errors and keeps your data layer maintainable.' },
          { title: 'Structured logging', description: 'Logging events as JSON with consistent fields so you can search, filter, and alert on production issues effectively.' },
          { title: 'Testing with Vitest / Jest', description: 'Writing automated tests for your API endpoints and business logic. A solid test suite lets you ship changes with confidence.' },
        ],
      },
      {
        level: 'advanced',
        label: 'Advanced',
        topics: [
          { title: 'Caching strategies (Redis)', description: 'Storing frequently accessed data in memory to reduce database load and response times. Redis provides fast, flexible caching with expiration and eviction policies.' },
          { title: 'Message queues & workers', description: 'Offloading slow or unreliable tasks to background workers using queues. This keeps your API responsive while heavy processing happens asynchronously.' },
          { title: 'WebSocket & real-time', description: 'Maintaining persistent connections for instant bidirectional communication. Essential for chat, notifications, and collaborative features.' },
          { title: 'Rate limiting & throttling', description: 'Protecting your API from abuse by limiting how many requests a client can make in a given time window.' },
          { title: 'Circuit breaker patterns', description: 'Preventing cascade failures by temporarily stopping requests to a failing dependency. Circuit breakers let your system degrade gracefully under pressure.' },
          { title: 'OpenAPI documentation', description: 'Generating interactive API docs from a formal specification. Good documentation reduces integration time and support requests.' },
          { title: 'CI/CD pipeline integration', description: 'Automating testing, building, and deployment so every code change is validated and shipped reliably.' },
        ],
      },
      {
        level: 'expert',
        label: 'Expert',
        topics: [
          { title: 'Microservices architecture', description: 'Splitting a large application into independently deployable services. This enables teams to work autonomously and scale services based on individual demand.' },
          { title: 'Horizontal scaling & load balancing', description: 'Running multiple instances of your service behind a load balancer to handle more traffic. This is how production systems achieve high availability.' },
          { title: 'Distributed tracing & observability', description: 'Tracking requests across multiple services to understand latency and diagnose failures. Observability turns opaque production systems into debuggable ones.' },
          { title: 'Security hardening (OWASP)', description: 'Applying the OWASP Top 10 mitigations to protect against injection, broken auth, and other common vulnerabilities in production APIs.' },
          { title: 'Event-driven architecture', description: 'Building systems where services communicate through events rather than direct calls. This decouples components and makes the system more resilient to failures.' },
          { title: 'Performance profiling & tuning', description: 'Identifying CPU and memory bottlenecks using profiling tools and optimizing hot paths. Small improvements in critical sections can dramatically increase throughput.' },
          { title: 'Zero-downtime deployments', description: 'Deploying new versions without dropping active connections or causing errors. Techniques like rolling updates and blue-green deploys keep users unaffected.' },
        ],
      },
    ],
  },
  {
    id: 'skill-4',
    slug: 'database-design',
    name: 'Database Design',
    category: 'database',
    proficiency: 80,
    icon: 'database',
    logoPath: '/logos/skills/database.svg',
    modelPath: '/models/skills/database.glb',
    description:
      'Modeling data that scales well and writing queries that stay fast as tables grow.',
    longDescription:
      'Good database design is the backbone of every reliable application. I work primarily with PostgreSQL and use Prisma as my ORM for type-safe queries. I think about access patterns before writing schemas, use indexes strategically, and know when to denormalize for performance. I have experience with materialized views for analytics, optimistic locking for concurrency, and migrations that run safely in production without downtime.',
    highlights: [
      'Designed schemas for apps serving 100K+ users with sub-200ms query times',
      'Used materialized views to speed up analytics queries by 10x',
      'Implemented zero-downtime migrations on production PostgreSQL databases',
    ],
    relatedProjectSlugs: [
      'collaborative-workspace',
      'event-booking-api',
      'analytics-dashboard',
    ],
    yearsOfExperience: 3,
    roadmap: [
      {
        level: 'beginner',
        label: 'Beginner',
        topics: [
          { title: 'SQL fundamentals (SELECT, INSERT, UPDATE)', description: 'The core commands for reading and writing data in a relational database. These operations are the foundation of every database interaction.' },
          { title: 'CRUD operations', description: 'Creating, reading, updating, and deleting records -- the four basic operations every application performs against its data store.' },
          { title: 'JOINs & relationships', description: 'Combining data from multiple tables based on related columns. Joins let you query normalized data without duplicating information.' },
          { title: 'Primary & foreign keys', description: 'Uniquely identifying rows and enforcing relationships between tables. Keys maintain data integrity and prevent orphaned records.' },
          { title: 'Basic data types', description: 'Choosing the right column types for your data: integers, text, timestamps, booleans, and more. Correct types improve storage efficiency and query performance.' },
          { title: 'Simple filtering & sorting', description: 'Using WHERE clauses and ORDER BY to retrieve exactly the data you need in the right order. This is how you turn raw tables into useful query results.' },
          { title: 'Database clients & GUIs', description: 'Tools like pgAdmin, DBeaver, or Prisma Studio that let you browse data, run queries, and inspect schemas visually.' },
        ],
      },
      {
        level: 'intermediate',
        label: 'Intermediate',
        topics: [
          { title: 'Schema design & ERD modeling', description: 'Planning your tables, columns, and relationships before writing code. Entity-relationship diagrams make it easier to spot design issues early.' },
          { title: 'Normalization (1NFâ€“3NF)', description: 'Organizing data to eliminate redundancy and prevent update anomalies. Normalization keeps your data consistent and your storage efficient.' },
          { title: 'Migrations & versioning', description: 'Tracking schema changes over time with versioned migration files. Migrations make database changes reproducible and safe to apply across environments.' },
          { title: 'Aggregations & subqueries', description: 'Computing summaries like counts, averages, and totals, and nesting queries for complex data retrieval. Essential for reporting and analytics features.' },
          { title: 'Prisma ORM patterns', description: 'Using Prisma for type-safe database queries, relations, and transactions in TypeScript. Prisma bridges your schema and your application code seamlessly.' },
          { title: 'Seeding & fixtures', description: 'Populating your database with initial or test data automatically. Seeds ensure every developer and CI environment starts with consistent data.' },
          { title: 'Connection pooling', description: 'Reusing database connections across requests to avoid the overhead of opening new ones. Pooling is critical for handling concurrent traffic efficiently.' },
        ],
      },
      {
        level: 'advanced',
        label: 'Advanced',
        topics: [
          { title: 'Indexing strategies (B-tree, GIN)', description: 'Creating the right indexes to speed up queries without wasting storage. B-tree indexes handle equality and range queries; GIN indexes power full-text and array searches.' },
          { title: 'Query plans & EXPLAIN ANALYZE', description: 'Reading execution plans to understand how the database processes your queries. This is the primary tool for diagnosing slow queries and missing indexes.' },
          { title: 'Transactions & isolation levels', description: 'Grouping operations so they succeed or fail as a unit, and controlling how concurrent transactions see each other\'s changes.' },
          { title: 'Optimistic & pessimistic locking', description: 'Preventing data conflicts when multiple users edit the same record. Optimistic locking detects conflicts at save time; pessimistic locking prevents them upfront.' },
          { title: 'Materialized views', description: 'Precomputing and storing expensive query results for fast reads. Materialized views trade freshness for speed, which is ideal for dashboards and reports.' },
          { title: 'Full-text search', description: 'Searching through large text columns using built-in database features instead of external search engines. PostgreSQL\'s tsvector and tsquery make this surprisingly capable.' },
          { title: 'Database triggers & functions', description: 'Running custom logic automatically when data changes. Triggers enforce business rules at the database level, guaranteeing consistency regardless of which app writes the data.' },
        ],
      },
      {
        level: 'expert',
        label: 'Expert',
        topics: [
          { title: 'Replication (primary-replica)', description: 'Copying data to read-only replicas to distribute query load and provide failover. Replication is the foundation of high-availability database architectures.' },
          { title: 'Sharding & partitioning', description: 'Splitting large tables across multiple servers or segments to maintain performance at scale. Partitioning keeps queries fast as data grows into billions of rows.' },
          { title: 'Distributed consensus', description: 'Ensuring multiple database nodes agree on the state of data using protocols like Raft or Paxos. Consensus is what makes distributed databases reliable.' },
          { title: 'Zero-downtime schema migrations', description: 'Changing production schemas without locking tables or causing errors for active users. Techniques like expand-contract migrations make this possible.' },
          { title: 'Performance benchmarking', description: 'Measuring query throughput and latency under realistic load to find bottlenecks before users do. Benchmarks validate that your optimizations actually work.' },
          { title: 'Multi-tenant architectures', description: 'Designing schemas that isolate data between customers while sharing infrastructure. The choice between shared tables, schemas, or databases affects cost and complexity.' },
          { title: 'Disaster recovery & backups', description: 'Planning for the worst with automated backups, point-in-time recovery, and tested restore procedures. A backup you have never restored is not a backup.' },
        ],
      },
    ],
  },
  {
    id: 'skill-5',
    slug: 'ui-ux-design',
    name: 'UI/UX Design',
    category: 'design',
    proficiency: 75,
    icon: 'design',
    logoPath: '/logos/skills/design.svg',
    modelPath: '/models/skills/design.glb',
    description:
      'Designing interfaces that look great and feel intuitive, from wireframe to polished pixel.',
    longDescription:
      'I bridge the gap between design and engineering. I work in Figma for wireframes and prototyping, then translate those designs into pixel-perfect code with Tailwind CSS. I care about the details that make interfaces feel alive: micro-interactions, smooth transitions, consistent spacing, and thoughtful color systems. Accessibility is always part of the design process, not an afterthought. Every component I build meets WCAG 2.1 AA standards.',
    highlights: [
      'Created a design system used across three production products',
      'Built accessible components meeting WCAG 2.1 AA standards',
      'Designed and shipped responsive layouts for 50+ pages',
      'Improved a SaaS onboarding flow, increasing completion rate by 25%',
    ],
    relatedProjectSlugs: [
      'motion-design-system',
      'analytics-dashboard',
      'collaborative-workspace',
    ],
    yearsOfExperience: 3,
    roadmap: [
      {
        level: 'beginner',
        label: 'Beginner',
        topics: [
          { title: 'Color theory & palettes', description: 'Understanding how colors interact, convey emotion, and create contrast. A well-chosen palette sets the tone for your entire interface.' },
          { title: 'Typography fundamentals', description: 'Selecting fonts, setting sizes, and managing line height and spacing to make text readable and visually appealing.' },
          { title: 'Spacing & layout basics', description: 'Using consistent margins, padding, and grids to create visual order. Good spacing makes designs feel polished and easy to scan.' },
          { title: 'Visual hierarchy', description: 'Guiding the viewer\'s eye to the most important content first through size, color, contrast, and positioning.' },
          { title: 'Basic wireframing', description: 'Sketching low-fidelity layouts to explore ideas quickly before committing to detailed designs. Wireframes save time by validating structure early.' },
          { title: 'Design tool navigation (Figma)', description: 'Getting comfortable with Figma\'s interface, frames, layers, and basic operations. Figma is the industry standard for collaborative design work.' },
          { title: 'Mood boards & inspiration', description: 'Collecting visual references to establish the aesthetic direction of a project. Mood boards align stakeholders on look and feel before detailed work begins.' },
        ],
      },
      {
        level: 'intermediate',
        label: 'Intermediate',
        topics: [
          { title: 'Component-based design', description: 'Building reusable UI elements with consistent behavior and appearance. Component thinking in design mirrors component thinking in code.' },
          { title: 'Responsive layout patterns', description: 'Designing interfaces that adapt gracefully from mobile to desktop screens. Responsive patterns ensure every user gets a good experience regardless of device.' },
          { title: 'Figma auto-layout & variants', description: 'Using auto-layout for flexible, responsive designs and variants for component states. These features make design files maintainable and scalable.' },
          { title: 'Icon systems', description: 'Creating or curating a consistent icon set that communicates clearly at small sizes. A unified icon system strengthens visual coherence across your product.' },
          { title: 'Interaction states (hover, focus, active)', description: 'Designing distinct visual feedback for every interactive state. Clear states make interfaces feel responsive and accessible to keyboard users.' },
          { title: 'Design handoff workflows', description: 'Preparing design files with specs, annotations, and assets so developers can implement them accurately. Good handoff reduces back-and-forth.' },
          { title: 'Usability heuristics', description: 'Evaluating interfaces against established principles like Nielsen\'s heuristics. These rules of thumb catch common usability problems without formal user testing.' },
        ],
      },
      {
        level: 'advanced',
        label: 'Advanced',
        topics: [
          { title: 'Design system architecture', description: 'Structuring tokens, components, and patterns into a cohesive system that scales across products. A strong architecture keeps the system consistent as it grows.' },
          { title: 'Motion design & micro-interactions', description: 'Adding purposeful animation to guide attention, provide feedback, and make interfaces feel alive. Good motion design is felt more than noticed.' },
          { title: 'Advanced prototyping', description: 'Building high-fidelity interactive prototypes that simulate real app behavior. Advanced prototypes validate complex flows before any code is written.' },
          { title: 'Token-based theming', description: 'Defining colors, spacing, and typography as design tokens that can be swapped for different themes. Tokens make dark mode and white-labeling straightforward.' },
          { title: 'Cross-platform design (web + mobile)', description: 'Adapting designs for different platforms while maintaining brand consistency. Each platform has its own conventions and constraints to respect.' },
          { title: 'Design QA processes', description: 'Reviewing implemented designs against specs to catch visual discrepancies before release. Design QA ensures the final product matches the intended experience.' },
          { title: 'Accessibility (WCAG 2.1 AA)', description: 'Designing for users with visual, motor, and cognitive disabilities by meeting established accessibility guidelines. Accessible design benefits everyone.' },
        ],
      },
      {
        level: 'expert',
        label: 'Expert',
        topics: [
          { title: 'User research & testing', description: 'Conducting interviews, usability tests, and surveys to base design decisions on real user behavior rather than assumptions.' },
          { title: 'Accessibility auditing & remediation', description: 'Systematically evaluating products for accessibility barriers and fixing them. Auditing ensures compliance and a better experience for all users.' },
          { title: 'Design ops & governance', description: 'Establishing processes, tools, and standards that help design teams work efficiently at scale. Design ops keeps quality high as the team and product grow.' },
          { title: 'Multi-brand design systems', description: 'Building a single design system that supports multiple brands through theming and configuration. This maximizes reuse while allowing brand differentiation.' },
          { title: 'Data-driven design decisions', description: 'Using analytics, A/B tests, and user metrics to validate and refine designs. Data removes subjectivity from design debates.' },
          { title: 'Design team mentorship', description: 'Guiding junior designers through feedback, pairing sessions, and structured growth plans. Mentorship multiplies the impact of your design skills.' },
          { title: 'Strategic design thinking', description: 'Connecting design work to business objectives and user outcomes. Strategic thinking ensures design effort is focused where it creates the most value.' },
        ],
      },
    ],
  },
  {
    id: 'skill-6',
    slug: 'ai-ml-integration',
    name: 'AI/ML Integration',
    category: 'ai-ml',
    proficiency: 70,
    icon: 'ai',
    logoPath: '/logos/skills/ai.svg',
    modelPath: '/models/skills/ai.glb',
    description:
      'Integrating large language models and ML pipelines into real products people use daily.',
    longDescription:
      'I got into AI integration two years ago when I built my first RAG pipeline for a marketing agency. Since then, I have worked with OpenAI, Anthropic, and open-source models to build features like content generation, semantic search, and conversational interfaces. I focus on the engineering side: prompt design, chunking strategies, vector storage, streaming responses, and keeping costs predictable. I believe AI features should feel seamless, not gimmicky.',
    highlights: [
      'Built a RAG pipeline that reduced content production time by 70%',
      'Implemented streaming chat interfaces with sub-100ms time to first token',
      'Designed prompt chains for consistent, brand-aligned content generation',
    ],
    relatedProjectSlugs: ['ai-content-engine', 'collaborative-workspace'],
    yearsOfExperience: 2,
    roadmap: [
      {
        level: 'beginner',
        label: 'Beginner',
        topics: [
          { title: 'Prompt engineering fundamentals', description: 'Writing clear, structured instructions that get reliable results from language models. Good prompts are the difference between useful output and noise.' },
          { title: 'OpenAI / Anthropic API basics', description: 'Making API calls to hosted language models, handling responses, and managing API keys. This is the starting point for any AI-powered feature.' },
          { title: 'Chat completion endpoints', description: 'Sending conversation-style messages to a model and receiving generated replies. Chat completions power chatbots, assistants, and interactive AI features.' },
          { title: 'Token counting & context limits', description: 'Understanding how models measure input length and what happens when you exceed the context window. Token awareness prevents truncation and unexpected costs.' },
          { title: 'Temperature & sampling parameters', description: 'Controlling how creative or deterministic model outputs are. Lower temperature gives consistent answers; higher temperature enables creative generation.' },
          { title: 'Streaming responses', description: 'Displaying model output token by token as it is generated instead of waiting for the full response. Streaming makes AI features feel fast and responsive.' },
          { title: 'Basic error handling & retries', description: 'Gracefully handling rate limits, timeouts, and API errors so your application stays reliable even when the model service has issues.' },
        ],
      },
      {
        level: 'intermediate',
        label: 'Intermediate',
        topics: [
          { title: 'Embeddings & vector databases', description: 'Converting text into numerical representations and storing them for similarity search. Embeddings are the foundation of semantic search and recommendation systems.' },
          { title: 'RAG pipeline design', description: 'Retrieving relevant documents and injecting them into prompts so the model answers using your data. RAG gives language models access to private or up-to-date information.' },
          { title: 'Chunking strategies', description: 'Splitting documents into appropriately sized pieces for embedding and retrieval. Chunk size and overlap directly affect retrieval quality and relevance.' },
          { title: 'Semantic search implementation', description: 'Finding content based on meaning rather than exact keyword matches. Semantic search dramatically improves search quality for natural language queries.' },
          { title: 'Prompt chaining & templates', description: 'Breaking complex tasks into multiple prompt steps and using templates for consistency. Chains let you build reliable workflows from unpredictable model outputs.' },
          { title: 'Function calling / tool use', description: 'Letting the model invoke structured functions to interact with external systems. Tool use turns a language model into an agent that can take real actions.' },
          { title: 'Cost tracking & optimization', description: 'Monitoring API spending per feature and reducing costs through caching, shorter prompts, and model selection. Cost awareness keeps AI features financially sustainable.' },
        ],
      },
      {
        level: 'advanced',
        label: 'Advanced',
        topics: [
          { title: 'Fine-tuning workflows', description: 'Training a model on your specific data to improve performance on domain-specific tasks. Fine-tuning can reduce prompt length and improve output consistency.' },
          { title: 'Agent architectures', description: 'Building autonomous systems that plan, reason, and use tools to accomplish complex goals. Agents extend what language models can do beyond single-turn interactions.' },
          { title: 'Multi-step reasoning chains', description: 'Guiding models through structured thinking processes to solve problems that require multiple logical steps.' },
          { title: 'Guardrails & content filtering', description: 'Preventing models from generating harmful, off-topic, or brand-inconsistent content. Guardrails are essential for any user-facing AI feature.' },
          { title: 'Evaluation frameworks', description: 'Measuring AI output quality systematically with automated metrics and human review. Without evaluation, you cannot know if changes improve or degrade performance.' },
          { title: 'A/B testing prompts', description: 'Comparing different prompt versions with real users to determine which produces better outcomes. Data-driven prompt iteration beats intuition.' },
          { title: 'Hybrid search (keyword + semantic)', description: 'Combining traditional keyword matching with vector similarity for more robust retrieval. Hybrid search handles both exact matches and conceptual queries.' },
        ],
      },
      {
        level: 'expert',
        label: 'Expert',
        topics: [
          { title: 'Production ML ops & monitoring', description: 'Running AI features reliably in production with logging, alerting, and performance tracking. ML ops ensures your models stay healthy after deployment.' },
          { title: 'Model evaluation at scale', description: 'Benchmarking model performance across thousands of test cases to catch regressions and compare model versions systematically.' },
          { title: 'Cost optimization & caching layers', description: 'Implementing response caching, prompt compression, and smart routing to reduce AI API costs by orders of magnitude at scale.' },
          { title: 'Multi-model orchestration', description: 'Routing tasks to different models based on complexity, cost, and capability. Using the right model for each task optimizes both quality and spend.' },
          { title: 'Custom model deployment', description: 'Hosting and serving open-source models on your own infrastructure for full control over latency, privacy, and cost.' },
          { title: 'Compliance & data privacy', description: 'Ensuring AI features meet regulatory requirements like GDPR and handle sensitive user data appropriately. Compliance is non-negotiable for enterprise adoption.' },
          { title: 'AI feature product strategy', description: 'Deciding which AI features to build, how to position them, and how to measure their business impact. Strategy ensures AI investments deliver real user value.' },
        ],
      },
    ],
  },
  {
    id: 'skill-7',
    slug: 'c-programming',
    name: 'C Programming',
    category: 'systems',
    proficiency: 75,
    icon: 'c',
    logoPath: '/logos/skills/c.svg',
    modelPath: '/models/skills/c.glb',
    description:
      'Writing efficient, low-level systems code with manual memory management and hardware awareness.',
    longDescription:
      'C gave me a deep understanding of how computers actually work. I use it for performance-critical code, embedded systems, and understanding the internals of higher-level tools I rely on daily. Working in C taught me to think about memory layout, pointer arithmetic, and the cost of every abstraction. I appreciate the discipline it demands -- every allocation has a matching free, every buffer has a known size.',
    highlights: [
      'Built custom memory allocators for performance-critical applications',
      'Implemented network protocols at the socket level',
      'Contributed patches to open-source C libraries',
      'Wrote embedded firmware for microcontroller-based projects',
    ],
    relatedProjectSlugs: [],
    yearsOfExperience: 3,
    roadmap: [
      {
        level: 'beginner',
        label: 'Beginner',
        topics: [
          { title: 'Variables, data types & operators', description: 'The building blocks of C programs: declaring variables, choosing types like int and char, and performing arithmetic and logical operations.' },
          { title: 'Control flow (if/else, loops, switch)', description: 'Directing program execution with conditionals and loops. Control flow is how you express logic and repeat operations in any C program.' },
          { title: 'Functions & parameter passing', description: 'Organizing code into reusable functions and understanding pass-by-value semantics. Functions are the primary unit of abstraction in C.' },
          { title: 'Arrays & strings', description: 'Working with contiguous blocks of data and null-terminated character arrays. Understanding arrays is essential because they map directly to memory layout.' },
          { title: 'Pointers & addresses', description: 'Storing and manipulating memory addresses directly. Pointers are what make C powerful and dangerous -- mastering them is the key to fluency.' },
          { title: 'Basic I/O (printf, scanf)', description: 'Reading input and printing output using formatted I/O functions. These standard library functions handle the most common user interaction patterns.' },
          { title: 'Compilation with gcc/clang', description: 'Turning source code into executables using a compiler. Understanding compilation flags and warnings helps you catch errors early.' },
        ],
      },
      {
        level: 'intermediate',
        label: 'Intermediate',
        topics: [
          { title: 'Dynamic memory (malloc, calloc, free)', description: 'Allocating and releasing memory at runtime for data structures that grow and shrink. Manual memory management gives you full control but requires discipline.' },
          { title: 'Structs & unions', description: 'Grouping related data into composite types. Structs model real-world entities; unions allow multiple interpretations of the same memory.' },
          { title: 'File I/O & streams', description: 'Reading and writing files using buffered streams with fopen, fread, and fwrite. File I/O is fundamental for persistent data and inter-process communication.' },
          { title: 'Header files & multi-file projects', description: 'Splitting code across multiple files with declarations in headers. This is how C projects scale beyond a single source file.' },
          { title: 'Makefiles & build systems', description: 'Automating compilation with dependency tracking so only changed files are recompiled. Makefiles are the traditional build tool for C projects of any size.' },
          { title: 'Preprocessor macros & directives', description: 'Using #define, #include, and conditional compilation to configure code before it reaches the compiler. Macros enable platform-specific code and compile-time constants.' },
          { title: 'Debugging with gdb & valgrind', description: 'Stepping through code to find logic errors and detecting memory leaks and invalid accesses. These tools are indispensable for writing correct C programs.' },
        ],
      },
      {
        level: 'advanced',
        label: 'Advanced',
        topics: [
          { title: 'Function pointers & callbacks', description: 'Storing references to functions and passing them as arguments for generic programming. Function pointers enable polymorphism and plugin architectures in C.' },
          { title: 'Bit manipulation & bitfields', description: 'Operating on individual bits for compact data representation and hardware register access. Bit manipulation is critical in embedded systems and protocol parsing.' },
          { title: 'Custom data structures (linked lists, trees)', description: 'Implementing fundamental data structures from scratch using pointers and dynamic memory. Building these yourself deepens understanding of algorithms and memory.' },
          { title: 'Socket programming', description: 'Building networked applications using the POSIX socket API for TCP and UDP communication. Socket programming connects your code to the network at the lowest level.' },
          { title: 'Signal handling & IPC', description: 'Responding to operating system signals and communicating between processes using pipes, shared memory, and message queues.' },
          { title: 'Thread programming (pthreads)', description: 'Running code concurrently using POSIX threads with proper synchronization via mutexes and condition variables.' },
          { title: 'Undefined behavior & compiler optimizations', description: 'Understanding what the C standard leaves unspecified and how compilers exploit those gaps. Avoiding undefined behavior is essential for writing portable, correct code.' },
        ],
      },
      {
        level: 'expert',
        label: 'Expert',
        topics: [
          { title: 'Custom memory allocators', description: 'Building specialized allocators tuned for specific access patterns like arena allocation or pool allocation. Custom allocators can dramatically reduce allocation overhead.' },
          { title: 'Lock-free data structures', description: 'Implementing concurrent data structures using atomic operations instead of mutexes. Lock-free designs eliminate contention and improve throughput in multi-threaded systems.' },
          { title: 'Embedded & bare-metal programming', description: 'Writing code that runs directly on hardware without an operating system. Bare-metal programming requires intimate knowledge of the target processor and peripherals.' },
          { title: 'Kernel module development', description: 'Extending operating system functionality by writing loadable kernel modules. Kernel programming demands precision because bugs crash the entire system.' },
          { title: 'Compiler internals & code generation', description: 'Understanding how compilers parse, optimize, and generate machine code from C source. This knowledge helps you write code that compilers optimize effectively.' },
          { title: 'Static analysis & formal verification', description: 'Using tools to prove properties about your code mathematically or detect bugs without running the program. Static analysis catches entire classes of errors automatically.' },
          { title: 'ABI compatibility & cross-compilation', description: 'Building binaries that work across different platforms and library versions. ABI awareness is essential for distributing C libraries and supporting multiple architectures.' },
        ],
      },
    ],
  },
  {
    id: 'skill-8',
    slug: 'rust',
    name: 'Rust',
    category: 'systems',
    proficiency: 65,
    icon: 'rust',
    logoPath: '/logos/skills/rust.svg',
    modelPath: '/models/skills/rust.glb',
    description:
      'Building safe, concurrent systems with zero-cost abstractions and no garbage collector.',
    longDescription:
      'Rust gives me the performance of C with the safety guarantees I wish C had. The ownership model clicked after a few frustrating weeks, and now it shapes how I think about resource management in every language. I use Rust for CLI tools, WebAssembly modules, and backend services where predictable latency matters. The ecosystem around cargo, clippy, and the type system makes it a joy to write correct code on the first try.',
    highlights: [
      'Built high-throughput CLI tools processing gigabytes of data',
      'Compiled Rust to WebAssembly for browser-based compute',
      'Implemented async services with Tokio for concurrent workloads',
      'Achieved zero unsafe blocks in production application code',
    ],
    relatedProjectSlugs: [],
    yearsOfExperience: 2,
    roadmap: [
      {
        level: 'beginner',
        label: 'Beginner',
        topics: [
          { title: 'Variables, mutability & shadowing', description: 'Understanding Rust\'s default immutability and when to opt into mutable bindings. Shadowing lets you reuse variable names while changing types safely.' },
          { title: 'Primitive types & compound types', description: 'Working with integers, floats, booleans, tuples, and arrays. Rust\'s type system catches size and overflow issues that other languages silently allow.' },
          { title: 'Functions & control flow', description: 'Defining functions with explicit parameter and return types, and using if/else, loops, and match for control flow.' },
          { title: 'Ownership & borrowing basics', description: 'Rust\'s core innovation: each value has one owner, and references borrow access without taking ownership. This eliminates data races and use-after-free bugs at compile time.' },
          { title: 'String vs &str', description: 'Understanding the difference between owned heap strings and borrowed string slices. This distinction is your first encounter with Rust\'s ownership model in practice.' },
          { title: 'Structs & enums', description: 'Defining custom data types with named fields and algebraic data types with variants. Rust enums are far more powerful than enums in most other languages.' },
          { title: 'Pattern matching & match', description: 'Destructuring data and handling every possible case exhaustively. The compiler ensures you never forget a variant, eliminating an entire class of bugs.' },
        ],
      },
      {
        level: 'intermediate',
        label: 'Intermediate',
        topics: [
          { title: 'Traits & generics', description: 'Defining shared behavior across types with traits and writing generic code that works with any type meeting certain constraints. Traits are Rust\'s approach to polymorphism.' },
          { title: 'Error handling (Result, Option, ?)', description: 'Using Result and Option types instead of exceptions for explicit, composable error handling. The ? operator keeps error propagation concise without hiding failures.' },
          { title: 'Iterators & closures', description: 'Processing sequences of data lazily and passing behavior as values. Rust\'s iterator chain optimizations often compile to the same code as hand-written loops.' },
          { title: 'Modules & crate structure', description: 'Organizing code into modules, files, and crates with controlled visibility. Good module structure makes large Rust projects navigable and maintainable.' },
          { title: 'Collections (Vec, HashMap)', description: 'Using Rust\'s standard collection types for dynamic arrays and key-value stores. Understanding ownership interactions with collections is key to productive Rust.' },
          { title: 'Cargo workspace & dependencies', description: 'Managing multi-crate projects and third-party dependencies with Cargo. Cargo handles building, testing, documentation, and publishing in one tool.' },
          { title: 'Testing & documentation', description: 'Writing unit tests, integration tests, and doc tests that double as executable examples. Rust\'s built-in test framework makes testing a natural part of development.' },
        ],
      },
      {
        level: 'advanced',
        label: 'Advanced',
        topics: [
          { title: 'Lifetimes & lifetime elision', description: 'Annotating how long references are valid to prevent dangling pointers. Lifetime elision rules handle most cases automatically, but complex scenarios require explicit annotations.' },
          { title: 'Smart pointers (Box, Rc, Arc)', description: 'Heap allocation, reference counting, and thread-safe shared ownership. Smart pointers extend Rust\'s ownership model for data structures that need shared or indirect access.' },
          { title: 'Concurrency with threads & channels', description: 'Running parallel code safely using threads and communicating between them with message-passing channels. Rust\'s type system prevents data races at compile time.' },
          { title: 'Async/await & Tokio runtime', description: 'Writing non-blocking concurrent code for I/O-heavy workloads using Rust\'s async system. Tokio provides the runtime, timers, and networking primitives for production async services.' },
          { title: 'Trait objects & dynamic dispatch', description: 'Using trait objects for runtime polymorphism when you need heterogeneous collections or plugin systems. Dynamic dispatch trades some performance for flexibility.' },
          { title: 'Macros (declarative & procedural)', description: 'Generating code at compile time to reduce boilerplate. Declarative macros handle pattern-based expansion; procedural macros can transform arbitrary Rust syntax.' },
          { title: 'FFI & C interop', description: 'Calling C libraries from Rust and exposing Rust functions to C callers. FFI lets you leverage existing C ecosystems while gradually adopting Rust.' },
        ],
      },
      {
        level: 'expert',
        label: 'Expert',
        topics: [
          { title: 'Unsafe Rust & raw pointers', description: 'Opting out of Rust\'s safety guarantees for low-level operations that the borrow checker cannot verify. Unsafe blocks should be minimal, well-documented, and wrapped in safe abstractions.' },
          { title: 'Custom allocators & no_std', description: 'Writing Rust code without the standard library for embedded or kernel environments, and providing custom memory allocation strategies.' },
          { title: 'Lock-free concurrency patterns', description: 'Building high-performance concurrent data structures using atomic operations. Lock-free designs eliminate mutex contention in performance-critical paths.' },
          { title: 'Compiler plugin development', description: 'Extending the Rust compiler with custom lints, diagnostics, and code transformations. Compiler plugins enforce project-specific rules at build time.' },
          { title: 'WebAssembly compilation & optimization', description: 'Compiling Rust to WebAssembly for near-native performance in the browser. Wasm-specific optimizations reduce binary size and startup time.' },
          { title: 'Performance profiling & benchmarking', description: 'Using criterion, perf, and flamegraphs to measure and optimize Rust code. Rust\'s zero-cost abstractions mean profiling often reveals surprising bottlenecks.' },
          { title: 'Embedded Rust & RTIC framework', description: 'Building firmware for microcontrollers using Rust\'s embedded ecosystem. RTIC provides a concurrency framework tailored for resource-constrained real-time systems.' },
        ],
      },
    ],
  },
  {
    id: 'skill-9',
    slug: 'python',
    name: 'Python',
    category: 'backend',
    proficiency: 80,
    icon: 'python',
    logoPath: '/logos/skills/python.svg',
    modelPath: '/models/skills/python.glb',
    description:
      'Scripting, automation, data processing, and rapid prototyping with clean, readable code.',
    longDescription:
      'Python is my go-to for anything that needs to be built fast and work reliably: automation scripts, data pipelines, API prototypes, and ML experimentation. I value its readability and the vast ecosystem of libraries. I use type hints and mypy on serious projects, and I know when to reach for pandas, FastAPI, or plain standard-library tools. Python taught me that clarity beats cleverness every time.',
    highlights: [
      'Automated data pipelines processing millions of records daily',
      'Built REST APIs with FastAPI and async database access',
      'Created CLI tools with Click for internal developer workflows',
      'Wrote data analysis scripts with pandas and NumPy',
    ],
    relatedProjectSlugs: ['ai-content-engine'],
    yearsOfExperience: 4,
    roadmap: [
      {
        level: 'beginner',
        label: 'Beginner',
        topics: [
          { title: 'Variables, types & operators', description: 'Python\'s dynamic typing lets you work quickly, but understanding types prevents subtle bugs. Operators cover arithmetic, comparison, and logical operations.' },
          { title: 'Control flow & loops', description: 'Using if/elif/else, for loops, and while loops to direct program execution. Python\'s clean syntax makes control flow easy to read and write.' },
          { title: 'Functions & scope', description: 'Defining reusable blocks of code with parameters and return values. Understanding scope rules prevents confusing bugs with variable visibility.' },
          { title: 'Lists, dicts, sets & tuples', description: 'Python\'s core data structures for ordered sequences, key-value mappings, unique collections, and immutable records. Choosing the right one impacts both clarity and performance.' },
          { title: 'String manipulation', description: 'Formatting, slicing, searching, and transforming text. String operations are used constantly in data processing, web development, and scripting.' },
          { title: 'File I/O & exceptions', description: 'Reading and writing files with context managers and handling errors gracefully. Try/except blocks let you recover from failures instead of crashing.' },
          { title: 'Modules & pip', description: 'Importing code from the standard library and installing third-party packages. Python\'s package ecosystem is one of its greatest strengths.' },
        ],
      },
      {
        level: 'intermediate',
        label: 'Intermediate',
        topics: [
          { title: 'List/dict/set comprehensions', description: 'Writing concise, readable expressions to transform and filter collections in a single line. Comprehensions are idiomatic Python and often faster than explicit loops.' },
          { title: 'Decorators & context managers', description: 'Wrapping functions with reusable behavior and managing resources that need cleanup. These patterns reduce boilerplate and prevent resource leaks.' },
          { title: 'Classes & OOP patterns', description: 'Modeling real-world concepts with classes, inheritance, and composition. OOP in Python is flexible and practical, not ceremony-heavy.' },
          { title: 'Virtual environments & packaging', description: 'Isolating project dependencies so different projects can use different library versions. Virtual environments prevent dependency conflicts.' },
          { title: 'Type hints & mypy', description: 'Adding optional static types to Python code and checking them with mypy. Type hints catch bugs early and serve as living documentation.' },
          { title: 'Unit testing (pytest)', description: 'Writing automated tests with pytest\'s simple syntax, fixtures, and parametrization. A good test suite is your safety net for refactoring.' },
          { title: 'Standard library deep dive (itertools, pathlib, collections)', description: 'Leveraging powerful built-in modules for iteration, file paths, and specialized data structures. The standard library often eliminates the need for external packages.' },
        ],
      },
      {
        level: 'advanced',
        label: 'Advanced',
        topics: [
          { title: 'Generators & coroutines', description: 'Producing values lazily to process large datasets without loading everything into memory. Generators are essential for streaming data and building pipelines.' },
          { title: 'Async/await (asyncio)', description: 'Writing concurrent I/O-bound code without threads using Python\'s async runtime. Asyncio shines for network services, web scraping, and API clients.' },
          { title: 'Metaclasses & descriptors', description: 'Customizing class creation and attribute access at a deep level. These features power frameworks like Django and SQLAlchemy behind the scenes.' },
          { title: 'FastAPI / Flask patterns', description: 'Building web APIs with modern Python frameworks. FastAPI offers automatic validation, documentation, and async support out of the box.' },
          { title: 'pandas & NumPy for data', description: 'Processing and analyzing structured data efficiently with vectorized operations. These libraries are the backbone of Python\'s data science ecosystem.' },
          { title: 'Profiling & optimization (cProfile)', description: 'Finding performance bottlenecks using profiling tools and optimizing the critical paths. Python is fast enough when you optimize the right 5% of your code.' },
          { title: 'C extensions & ctypes', description: 'Calling compiled C code from Python for performance-critical operations. This bridges Python\'s productivity with C\'s speed when you need both.' },
        ],
      },
      {
        level: 'expert',
        label: 'Expert',
        topics: [
          { title: 'CPython internals & bytecode', description: 'Understanding how the Python interpreter compiles and executes code at the bytecode level. This knowledge helps you write faster code and debug mysterious behavior.' },
          { title: 'Custom import machinery', description: 'Modifying how Python finds and loads modules for custom package formats or dynamic code loading. Import hooks enable plugin systems and non-standard module sources.' },
          { title: 'Multiprocessing & GIL strategies', description: 'Working around the Global Interpreter Lock to achieve true parallelism. Multiprocessing and process pools let CPU-bound Python code use all available cores.' },
          { title: 'Building production ML pipelines', description: 'Orchestrating data ingestion, model training, evaluation, and deployment as reproducible automated workflows.' },
          { title: 'Package publishing (PyPI)', description: 'Packaging and distributing Python libraries for others to install with pip. Proper packaging includes metadata, versioning, and automated releases.' },
          { title: 'Static analysis (ruff, pylint)', description: 'Using fast linters and code analyzers to enforce style, catch bugs, and maintain consistency across large codebases.' },
          { title: 'Large-scale monorepo tooling', description: 'Managing many Python packages in a single repository with shared tooling, consistent standards, and efficient CI pipelines.' },
        ],
      },
    ],
  },
  {
    id: 'skill-10',
    slug: 'networking',
    name: 'Networking',
    category: 'networking',
    proficiency: 70,
    icon: 'networking',
    logoPath: '/logos/skills/networking.svg',
    modelPath: '/models/skills/networking.glb',
    description:
      'Understanding network protocols, architecture, and security from the physical layer to the application layer.',
    longDescription:
      'Networking knowledge underpins everything I build on the web. I understand TCP/IP, DNS, TLS, and HTTP at a level that lets me debug production issues others find mysterious. I have configured load balancers, set up VPNs, analyzed packet captures with Wireshark, and designed network architectures for multi-region deployments. This knowledge makes me a better backend engineer because I understand what happens between the client and my code.',
    highlights: [
      'Diagnosed and resolved complex latency issues using packet analysis',
      'Configured multi-region deployments with CDN and load balancing',
      'Implemented TLS termination and certificate automation',
      'Designed network security policies and firewall rules',
    ],
    relatedProjectSlugs: [],
    yearsOfExperience: 3,
    roadmap: [
      {
        level: 'beginner',
        label: 'Beginner',
        topics: [
          { title: 'OSI & TCP/IP model layers', description: 'The conceptual frameworks that describe how data moves from application to wire. Understanding layers helps you isolate problems when debugging network issues.' },
          { title: 'IP addressing & subnetting', description: 'Assigning addresses to devices and dividing networks into logical segments. Subnetting controls traffic flow and is fundamental to network design.' },
          { title: 'DNS resolution & records', description: 'How domain names get translated to IP addresses using a hierarchical lookup system. DNS is involved in every web request and is a common source of issues.' },
          { title: 'HTTP request/response lifecycle', description: 'The sequence of events from the moment a browser sends a request to when it receives a response. Understanding this lifecycle is essential for web developers.' },
          { title: 'MAC addresses & ARP', description: 'How devices identify each other on a local network and resolve IP addresses to hardware addresses. ARP operates at the link layer beneath IP.' },
          { title: 'Basic CLI tools (ping, traceroute, nslookup)', description: 'Command-line utilities for testing connectivity, tracing network paths, and querying DNS. These are the first tools you reach for when diagnosing network problems.' },
          { title: 'LAN vs WAN fundamentals', description: 'The difference between local and wide-area networks and how they connect. Understanding this distinction frames how traffic flows between your users and your servers.' },
        ],
      },
      {
        level: 'intermediate',
        label: 'Intermediate',
        topics: [
          { title: 'TCP vs UDP deep dive', description: 'Understanding the trade-offs between reliable, ordered delivery with TCP and fast, lightweight communication with UDP. Protocol choice directly affects application performance and behavior.' },
          { title: 'TLS/SSL handshake & certificates', description: 'How encrypted connections are established and how certificates verify server identity. TLS secures nearly all modern web traffic.' },
          { title: 'Routing & BGP basics', description: 'How packets find their way across the internet through routers and autonomous systems. BGP is the protocol that holds the internet together.' },
          { title: 'Firewalls & NAT', description: 'Controlling which traffic enters and leaves your network and translating between private and public IP addresses. Firewalls and NAT are fundamental to network security.' },
          { title: 'VLANs & network segmentation', description: 'Dividing a physical network into isolated logical segments for security and performance. Segmentation limits the blast radius of security incidents.' },
          { title: 'Wireshark & packet analysis', description: 'Capturing and inspecting individual network packets to diagnose issues at the protocol level. Packet analysis reveals what is actually happening on the wire.' },
          { title: 'HTTP/2 & HTTP/3 (QUIC)', description: 'Modern HTTP protocols that improve performance through multiplexing, header compression, and UDP-based transport. These protocols reduce latency for web applications.' },
        ],
      },
      {
        level: 'advanced',
        label: 'Advanced',
        topics: [
          { title: 'Load balancing algorithms (L4 vs L7)', description: 'Distributing traffic across servers using transport-layer or application-layer strategies. The balancing layer you choose affects routing flexibility, SSL handling, and performance.' },
          { title: 'CDN architecture & caching', description: 'Serving content from edge locations close to users to reduce latency. CDNs handle the majority of static and increasingly dynamic web traffic.' },
          { title: 'VPN protocols (WireGuard, IPSec)', description: 'Creating secure tunnels between networks or remote users. WireGuard offers modern simplicity; IPSec provides broad compatibility and enterprise features.' },
          { title: 'Socket programming & raw sockets', description: 'Building custom network applications at the socket level and inspecting raw packet data. Socket programming gives you full control over network communication.' },
          { title: 'Network security (IDS/IPS)', description: 'Detecting and preventing malicious traffic with intrusion detection and prevention systems. These tools add a layer of defense beyond firewalls.' },
          { title: 'Service mesh & sidecar proxies', description: 'Managing service-to-service communication with dedicated infrastructure proxies like Envoy. Service meshes handle mTLS, retries, and observability transparently.' },
          { title: 'DNS security (DNSSEC, DoH, DoT)', description: 'Protecting DNS queries from tampering and eavesdropping. DNSSEC validates responses; DoH and DoT encrypt the queries themselves.' },
        ],
      },
      {
        level: 'expert',
        label: 'Expert',
        topics: [
          { title: 'SDN & network automation', description: 'Managing network infrastructure programmatically through software-defined networking. Automation eliminates manual configuration errors and enables infrastructure as code.' },
          { title: 'BGP peering & traffic engineering', description: 'Controlling how traffic enters and exits your network by managing BGP relationships and route advertisements. Traffic engineering optimizes cost and performance at scale.' },
          { title: 'DDoS mitigation strategies', description: 'Protecting services from distributed denial-of-service attacks using traffic scrubbing, rate limiting, and anycast distribution.' },
          { title: 'Zero-trust network architecture', description: 'Eliminating implicit trust and verifying every request regardless of network location. Zero-trust is the modern approach to securing distributed systems.' },
          { title: 'Network performance tuning (kernel params)', description: 'Adjusting OS-level TCP settings, buffer sizes, and congestion control algorithms to maximize throughput and minimize latency for your specific workload.' },
          { title: 'Multi-region network design', description: 'Architecting networks that span multiple geographic regions with redundancy, failover, and optimized routing between data centers.' },
          { title: 'Protocol design & implementation', description: 'Creating custom application-layer protocols for specialized communication needs. Protocol design requires balancing efficiency, extensibility, and debuggability.' },
        ],
      },
    ],
  },
];

export function getSkillBySlug(slug: string): Skill | undefined {
  return skills.find((s) => s.slug === slug);
}

export function getSkillsByCategory(category: Skill['category']): Skill[] {
  return skills.filter((s) => s.category === category);
}
